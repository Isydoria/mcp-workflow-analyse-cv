"""
MCP Server for Analyse-CV using fastapi-mcp
Generated by LightOn Workflow Builder

This server exposes the workflow via proper MCP protocol for integration with:
- LightOn Paradigm (MCP integration)
- Claude Desktop
- Any MCP-compatible client

Usage:
    python -m mcp_server --port 8080
"""

import argparse
import asyncio
import logging
import os
from typing import List, Optional

from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from fastapi_mcp import FastApiMCP
from pydantic import BaseModel, Field
import uvicorn

from workflow import WorkflowExecutor
from paradigm_client import ParadigmClient

# Load environment variables from .env file
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title="Analyse-CV MCP Server",
    description="Analyse et compare automatiquement 5 CV par rapport √† une fiche de poste, en √©valuant chaque candidat selon des crit√®res pond√©r√©s et g√©n√®re un rapport professionnel avec scores et recommandations.",
    version="1.0.0"
)

# Initialize MCP server (must be done before defining tools)
mcp = FastApiMCP(app)

# Server configuration
PARADIGM_API_KEY = os.getenv("PARADIGM_API_KEY")
PARADIGM_BASE_URL = os.getenv("PARADIGM_BASE_URL", "https://paradigm.lighton.ai")


# Request/Response models
class AnalyseRequest(BaseModel):
    """Request model for CV analysis"""
    file_paths: Optional[List[str]] = Field(
        None,
        description="Chemins complets des fichiers locaux a analyser (ex: C:\\Documents\\cv.pdf)"
    )
    file_ids: Optional[List[int]] = Field(
        None,
        description="IDs des documents Paradigm a analyser"
    )
    query: Optional[str] = Field(
        None,
        description="Question ou demande d'analyse (optionnel)"
    )

    class Config:
        extra = "allow"  # Allow additional fields from Paradigm MCP

    def model_post_init(self, __context) -> None:
        """Validate that at least one file input method is provided"""
        if not self.file_paths and not self.file_ids:
            raise ValueError("Either file_paths or file_ids must be provided")


class AnalyseResponse(BaseModel):
    """Response model for CV analysis"""
    result: dict = Field(..., description="Analysis results")
    status: str = Field(..., description="Execution status")


# Helper function for resolving Paradigm filenames to IDs
async def _resolve_paradigm_filenames(
    paradigm_client: ParadigmClient,
    filenames: List[str]
) -> List[int]:
    """
    Resolve Paradigm document filenames to their IDs by listing user files.

    This function fetches the list of user files and matches by exact filename.

    Args:
        paradigm_client: Initialized Paradigm client
        filenames: List of document filenames to resolve

    Returns:
        List of resolved file IDs

    Raises:
        Exception: If any filename cannot be resolved
    """
    # Get list of ALL accessible files using v3 API (no filter)
    try:
        all_files = await paradigm_client.list_files(private=None)
        logger.info(f"üìã Retrieved {len(all_files)} files using v3 API (all accessible)")
    except Exception as e:
        logger.error(f"‚ùå Failed to list files: {str(e)}")
        raise Exception(f"Failed to list user files: {str(e)}")

    # Create a mapping of filename -> file_id
    # Store both with and without extension for flexible matching
    filename_to_id = {}
    for file in all_files:
        # Log first file to see structure
        if len(filename_to_id) == 0:
            logger.info(f"üîç First file structure: {file}")

        file_name = file.get('filename') or file.get('name')
        file_id = file.get('id')
        if file_name and file_id:
            # Store with full filename
            filename_to_id[file_name] = file_id

            # Also store without extension (for cases like "CV_Sophie_BERNARD" vs "CV_Sophie_BERNARD.pdf")
            name_without_ext = file_name.rsplit('.', 1)[0] if '.' in file_name else file_name
            if name_without_ext != file_name:
                filename_to_id[name_without_ext] = file_id

            # Also store with .pdf extension added (if not already present)
            if not file_name.endswith('.pdf'):
                filename_to_id[file_name + '.pdf'] = file_id

    logger.info(f"üìù File mapping created with {len(filename_to_id)} entries (including variants)")

    # Resolve each requested filename
    file_ids = []
    for filename in filenames:
        if filename in filename_to_id:
            file_id = filename_to_id[filename]
            file_ids.append(file_id)
            logger.info(f"‚úÖ Resolved '{filename}' to file ID: {file_id}")
        else:
            logger.error(f"‚ùå File not found: '{filename}'")
            logger.info(f"Available files: {list(filename_to_id.keys())[:10]}...")
            raise Exception(f"Document not found: {filename}")

    return file_ids


@app.post("/analyse_cv", response_model=AnalyseResponse, operation_id="analyse_cv")
async def analyse_cv(request: AnalyseRequest) -> AnalyseResponse:
    """
    Analyse and compare CVs against a job description.

    This endpoint executes a complete workflow using the LightOn Paradigm API.
    """
    try:
        # Log incoming request for debugging
        logger.info(f"üì® Received request: file_paths={request.file_paths}, file_ids={request.file_ids}, query={request.query}")

        # Log ALL fields in the request (including extra fields from Paradigm)
        request_dict = request.model_dump()
        logger.info(f"üîç Full request dump: {request_dict}")

        # Validate Paradigm API key
        if not PARADIGM_API_KEY:
            raise HTTPException(
                status_code=500,
                detail="PARADIGM_API_KEY not configured on server"
            )

        # Initialize Paradigm client
        paradigm_client = ParadigmClient(
            api_key=PARADIGM_API_KEY,
            base_url=PARADIGM_BASE_URL
        )

        # Determine input mode and handle file resolution
        file_ids_to_use = []

        if request.file_ids:
            # Direct file IDs provided
            logger.info(f"Using {len(request.file_ids)} provided file IDs")
            file_ids_to_use = request.file_ids

        elif request.file_paths:
            # Check if file_paths are actually Paradigm document names (no path separators)
            are_paradigm_names = all('/' not in fp and '\\' not in fp for fp in request.file_paths)

            if are_paradigm_names:
                # These are Paradigm document names, search for them
                logger.info(f"Detected {len(request.file_paths)} Paradigm document names, searching for IDs...")
                file_ids_to_use = await _resolve_paradigm_filenames(
                    paradigm_client,
                    request.file_paths
                )
                logger.info(f"Resolved to file IDs: {file_ids_to_use}")
            else:
                # These are actual file paths, pass them as-is
                logger.info(f"Using {len(request.file_paths)} local file paths")

        # Initialize workflow executor
        executor = WorkflowExecutor(paradigm_client)

        # Execute workflow with appropriate parameters
        exec_params = {"query": request.query}

        if file_ids_to_use:
            exec_params["file_ids"] = file_ids_to_use
        elif request.file_paths:
            exec_params["file_paths"] = request.file_paths

        result = await executor.execute(**exec_params)

        logger.info("Workflow execution completed successfully")

        return AnalyseResponse(
            result=result,
            status="success"
        )

    except Exception as e:
        logger.error(f"Workflow execution failed: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail=f"Workflow execution failed: {str(e)}"
        )


# Health check endpoint
@app.get("/health")
async def health():
    """Health check endpoint"""
    return {"status": "healthy"}


# Re-register all tools after defining endpoints
mcp.setup_server()

# Mount MCP HTTP endpoint
mcp.mount_http()

logger.info("MCP server mounted at /mcp endpoint")
logger.info(f"Paradigm API URL: {PARADIGM_BASE_URL}")
logger.info("Server is ready to accept MCP connections")


def main():
    """Main entry point for MCP server"""
    parser = argparse.ArgumentParser(description="MCP Server for Analyse-CV")
    parser.add_argument(
        "--port",
        type=int,
        default=8080,
        help="Port to listen on (default: 8080)"
    )
    parser.add_argument(
        "--host",
        type=str,
        default="0.0.0.0",
        help="Host to bind to (default: 0.0.0.0)"
    )

    args = parser.parse_args()

    logger.info(f"Starting MCP Server for Analyse-CV")
    logger.info(f"Host: {args.host}")
    logger.info(f"Port: {args.port}")
    logger.info(f"MCP endpoint will be available at: http://{args.host}:{args.port}/mcp")

    uvicorn.run(
        app,
        host=args.host,
        port=args.port,
        log_level="info"
    )


if __name__ == "__main__":
    main()
